# 리서치 및 가설 수립: 입 (Mouth / Extractor) 모듈

## 1단계: 필요(Need) 규정
*   **목적**: 오버마인드(에이전트)가 외부 세상의 원시 데이터(웹페이지 텍스트, 로컬 문서 등)를 가장 빠르고 정확하게 삼켜서(읽어와서) 채팅창 컨텍스트(뇌)로 전달하는 수족(스크립트)이 필요함.
*   **요구사항**: 터미널에서 간단한 명령어로 실행 가능해야 하며, 쓸데없는 HTML 태그 등을 걷어내고 순수한 '정보'만 반환해야 함.

## 2단계: 외부 지식 탐색
*   Python 텍스트 추출의 대표적 방식 비교:
    1.  `requests` + `BeautifulSoup`: 가장 빠르지만 JS로 로드되는 동적 페이지를 못 읽음.
    2.  `Playwright` / `Selenium`: 동적 페이지도 읽을 수 있지만, 브라우저를 띄워야 해서 무겁고 느림.
    3.  `Jina.ai` API / `Firecrawl` API: 최근 유행하는 LLM 친화적 마크다운 추출 API. 속도도 빠르고 파싱 퀄리티가 제일 좋으나 API 키/의존성이 생김.

## 3단계: 가설 수립 (Hypothesis Generation)

*   **원시 형태 (v1.0)**: `requests` + `BeautifulSoup` 조합
    *   가장 기초적인 스크립트. 정적인 텍스트만 긁어옵니다. 일단 파이프라인이 뚫리는지 확인하는 용도로 적합합니다.
*   **적응 형태 (v2.0)**: `Playwright` (Headless) 적용
    *   v1.0이 JS 렌더링 사이트를 못 먹는(파싱 에러) 실패를 겪고 나면 진화할 형태. 모든 웹페이지를 DOM 렌더링 후 긁어옵니다.
*   **최종 진화 형태 (v3.0)**: `Jina Reader API` 활용 또는 `Vision LLM` 연동
    *   아예 브라우저 렌더링 화면을 스크린샷으로 찍어 Vision 모델이 텍스트와 UI 구조를 한 번에 이해하게 하거나, LLM 전용 파싱 API를 도입하여 완벽한 마크다운을 뇌로 직행시킵니다.

## 4단계: 첫 진화 방향 결정 (Decision)
*   **결정**: 가장 만들기 쉽고 에러 파악이 확실한 **원시 형태 (v1.0)**부터 제작합니다. 
*   **Action**: `tools/mouth_v1.py` 스크립트를 작성하고 특정 웹페이지를 타겟으로 삼켜본 뒤, `회고_및_진화.md`를 거치겠습니다.
